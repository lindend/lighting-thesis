#include "globals.incl"

struct INPUT
{
	float4 pos : POSITION;
};

struct PATCHCONSTANT
{
	float tess[2] : SV_TessFactor;
	int3 idx : MINMAXINDEX;
	float4 dir : DIRECTION;
};

float2 toLVSpaceBase0(float2 pos)
{
	return ((pos - LVStart.xy) / (LVCellSize.xy * LVCellSize.w));
}

float2 toLVSpace(float2 pos)
{
	return ((pos - LVStart.xy) / (LVCellSize.xy * LVCellSize.w)) * 2.f - 1.f;
}


float2 findRelZ(float pos0z, float pos1z)
{
	return (float2(pos0z, pos1z) - LVStart.z) / LVCellSize.z;
}

//Puts the smallest of relZ in x component, and converts both to ints
int2 processRelZ(float2 relZ)
{
	return int2(floor(min(relZ.x, relZ.y)), ceil(max(relZ.x, relZ.y)));
}

float3 parseColor(float v)
{
	uint color = asuint(v);
	return float3(	(color & 0xFF) / 255.f,
					((color >> 8) & 0xFF) / 255.f,
					((color >> 16) & 0xFF) / 255.f);
}

PATCHCONSTANT constDataFunct(InputPatch<INPUT, 2> patch, uint patchId : SV_PrimitiveID)
{
	//Relative start and end z
	float2 relZ = findRelZ(patch[0].pos.z, patch[1].pos.z);
	
	//Clamp it to the [0, numCells] range
	float2 clampRelZ = float2(clamp(relZ.x, 0.f, LVCellSize.w), clamp(relZ.y, 0.f, LVCellSize.w));
	//Find the number of cells that the ray touches
	clampRelZ = processRelZ(clampRelZ);
	int numZ = clampRelZ.y - clampRelZ.x;

	float2 lvSpace0 = ceil(toLVSpaceBase0(patch[0].pos.xy));
	float2 lvSpace1 = ceil(toLVSpaceBase0(patch[1].pos.xy));
	
	//lvSpace will contain 1 if the point is inside the LV
	float2 insideLV = lvSpace0 * lvSpace1;

	PATCHCONSTANT output;
	//Set the density tessellation to numZ, this will basically generate numZ instances of our line
	output.tess[0] = numZ * (insideLV.x * insideLV.y <= 1 ? 1 : 0);
	//Do not split the line by setting the detail tessellation to 1
	output.tess[1] = 1.f;
	//output.color = parseColor(patch[0].pos.w);
	output.idx = uint3(clampRelZ, numZ);
	output.dir.xyz = normalize(patch[1].pos.xyz - patch[0].pos.xyz);
	output.dir.w = patch[0].pos.w;

	return output;
}

[domain("isoline")]
[partitioning("integer")]
[outputtopology("line")]
[outputcontrolpoints(2)]
[patchconstantfunc("constDataFunct")]
INPUT HSmain( 
    InputPatch<INPUT, 2> ip, 
    uint i : SV_OutputControlPointID,
    uint PatchID : SV_PrimitiveID )
{
	INPUT output = ip[i];
	output.pos.xy = toLVSpace(output.pos.xy);
	return output;
}

struct DS_OUTPUT
{
	float4 dir : DIRECTION;
	float4 pos : SV_Position;
};


[domain("isoline")]
DS_OUTPUT DSmain(PATCHCONSTANT input, float2 UV : SV_DomainLocation, const OutputPatch<INPUT, 2> patches)
{
	DS_OUTPUT output;

	output.dir = input.dir;
	output.pos.xyz = patches[1].pos.xyz * UV.x + (1.f - UV.x) * patches[0].pos.xyz;
	//output.color = input.color;

	//UV.y contains the "instance id" and is ranged [0 .. (numZ - 1) / numZ]
	output.pos.w = input.idx.x + UV.y * input.idx.z;//round(UV.x * (input.idx.y - input.idx.x) + input.idx.x);

	return output;
}
cbuffer LVInfo : register(c0)
{
	float3 LVStart;
	float3 LVEnd;
	//xyz - size, w - num cells
	float4 LVCellSize;
};

struct INPUT
{
	float3 color : COLOR;
	float3 dir : DIRECTION;
	float4 pos : SV_Position;
};

struct PATCHCONSTANT
{
	float tess[2] : SV_TessFactor;
	float3 color : COLOR;
	int2 idx : MINMAXINDEX;
	float3 dir : DIRECTION;
};

float2 findRelZ(float pos0z, float pos1z)
{
	return (float2(pos0z, pos1z) - LVStart.z) / LVCellSize.z;
}

//Puts the smallest of relZ in x component, and converts both to ints
int2 processRelZ(float2 relZ)
{
	return int2(floor(min(relZ.x, relZ.y)), ceil(max(relZ.x, relZ.y)));
}

PATCHCONSTANT constDataFunct(InputPatch<INPUT, 2> patch, uint patchId : SV_PrimitiveID)
{
	//Relative start and end z
	float2 relZ = findRelZ(patch[0].pos.z, patch[1].pos.z);
	
	//Clamp it to the [0, numCells] range
	float2 clampRelZ = float2(clamp(relZ.x, 0.f, LVCellSize.w), clamp(relZ.y, 0.f, LVCellSize.w));
	//Find the number of cells that the ray touches
	clampRelZ = processRelZ(clampRelZ);
	int numZ = clampRelZ.y - clampRelZ.x;

	PATCHCONSTANT output;
	//Set the detail tessellation to numZ, this will basically generate numZ instances of our line
	output.tess[0] = numZ;
	//Do not split the line
	output.tess[1] = 1.f;
	output.idx = processRelZ(relZ);
	output.color = patch[0].color;
	output.dir = normalize(patch[1].pos.xyz - patch[0].pos.xyz);

	return output;
}

[domain("isoline")]
[partitioning("integer")]
[outputtopology("line")]
[outputcontrolpoints(2)]
[patchconstantfunc("constDataFunct")]
INPUT HSmain( 
    InputPatch<INPUT, 2> ip, 
    uint i : SV_OutputControlPointID,
    uint PatchID : SV_PrimitiveID )
{
	return ip[i];
}

struct DS_OUTPUT
{
	float3 color : COLOR0;
	float3 dir : DIRECTION;
	float4 pos : SV_Position;
};


[domain("isoline")]
DS_OUTPUT DSmain(PATCHCONSTANT input, float2 UV : SV_DomainLocation, const OutputPatch<INPUT, 2> patches)
{
	DS_OUTPUT output;
	
	output.color = input.color;
	output.dir = input.dir;
	output.pos.xyz = patches[1].pos.xyz * UV.x + (1.f - UV.x) * patches[0].pos.xyz;

	//UV.y contains the "instance id" and is ranged [0 .. numZ - 1]
	output.pos.w = input.idx.x + UV.y;//round(UV.x * (input.idx.y - input.idx.x) + input.idx.x);

	return output;
}
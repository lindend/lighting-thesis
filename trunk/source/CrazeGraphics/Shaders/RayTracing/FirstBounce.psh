#include "globals.incl"
#include "RayTracing/PhotonRay.incl"

AppendStructuredBuffer<PhotonRay> OutRays : register(u1);

cbuffer FrustumInfo : register(b1)
{
	float3 corners[8];
	float3 intensity;
};

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), LightViewProj);
	return worldPos.xyz / worldPos.w;
}

float2 toPolar(float3 v)
{
	return float2(atan(v.y / v.x), acos(v.z));
}

float3 fromPolar(float theta, float phi)
{
	float sinTheta, cosTheta;
	float sinPhi, cosPhi;
	sincos(theta, sinTheta, cosTheta);
	sincos(phi, sinPhi, cosPhi);
	return float3(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
}
float3 fromPolar(float2 thetaPhi)
{
	return fromPolar(thetaPhi.x, thetaPhi.y);
}

float3 clampToHemisphere(float3 v, float3 n)
{
	return dot(v, n) < 0.f ? normalize(v - n * dot(n, v)) : normalize(v);
}

static const uint4 indices[] = 
{
	uint4(0, 1, 2, 3), //back
	uint4(5, 4, 7, 6), //forward
	uint4(1, 0, 4, 5), //top
	uint4(1, 5, 6, 2), //right
	uint4(2, 6, 7, 3), //bottom
	uint4(3, 7, 4, 0) //left
};

float3 calcFrustumNormal(int frustumIndex)
{
	//(V2 - V1) x (V3 - V1)
	uint4 side = indices[frustumIndex];
	float3 v0 = corners[side.x];
	float3 v1 = corners[side.y];
	float3 v2 = corners[side.w];
	return normalize(cross(v1 - v0, v2 - v0));
}

bool rayIntersectsFrustum1(float3 rayOrigin, float3 rayDir, out float maxEnter, out float minExit)
{
	maxEnter = -213321456621321122131.0f;
	minExit = 1315677621313213321.0f;
	//bool inside[6];
	bool inside = true;
	for(int i = 0; i < 6; ++i)
	{
		float3 frustumN = calcFrustumNormal(i);
		float frustDotDir = dot(frustumN, rayDir);
		float signDist = dot(frustumN , corners[indices[i].x] - rayOrigin);
		inside = inside && (signDist < 0.f || frustDotDir > 0.f);
		
		if(abs(frustDotDir) > 0.00001f) //if == 0, ray is parallel to plane so they either always intersect or never does
		{
			float intersection = signDist / frustDotDir;
			
			if(frustDotDir > 0.f)
			{
				maxEnter = max(intersection, maxEnter);
			}
			else
			{
				minExit = min(intersection, minExit);
			}
		}
	}
	//return inside;

	return maxEnter < minExit && minExit > 0.f;
}

bool rayIntersectsLV(float3 o, float3 d)
{
	float3 invDir = rcp(d);
	float3 tBegin = (LVStart - o) * invDir;
	float3 tEnd = (LVEnd - o) * invDir;
	 
	float3 tEnter = min(tBegin, tEnd);
	float3 tExit = max(tBegin, tEnd);
	float tMaxEnter = max(tEnter.x, max(tEnter.y, tEnter.z));
	float tMinExit = min(tExit.x, min(tExit.y, tExit.z));
	return tMaxEnter < tMinExit;
}

float3 toPSpace(float3 v, float w = 1.f)
{
	float4 ps = mul(float4(v, w), ViewProj);
	ps.xyz /= ps.w;
	return ps.xyz;
}
bool rayIntersectsFrustum(float3 psOrigin, float3 o, float3 d)
{
	float3 dir = toPSpace(d, 0.f);
	float3 toMin = float3(-1.f, -1.f, 0.f) - psOrigin;
	float3 toMax = float3(1.f, 1.f, 1.f) - psOrigin;
	float3 tMins = toMin / dir;
	float3 tMaxs = toMax / dir;

	float3 dirSign = sign(dir);
	float3 posDirMask = max(0.f, dirSign);
	float3 negDirMask = max(0.f, -dirSign);
	float3 enters = posDirMask * tMins + negDirMask * tMaxs;
	float3 exits = negDirMask * tMins + posDirMask * tMaxs;

	return max(enters.x, max(enters.y, enters.z)) <= min(exits.x, min(exits.y, exits.z));
}

uint touint(float v)
{
	return 0xFF & (uint)(v * 255.f);
}

/*#define RAYS_PER_TEXEL 1
float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	if (dot(normal, normal) < 0.5f)
	{
		discard;
	}

	float3 color = ColorSpec.Sample(Point, uv).xyz * intensity;
	float depth = Depth.Sample(Point, uv).x;
	float3 position = DepthToPos(depth, uv);
	//position = floor(position / 2.f) * 2.f;
	float3 psPos = toPSpace(position);

	float2 rndUvBase = position.xz * position.y;// / 10.f;//floor(frac(position.xz * 0.001f) * 128.f) / 128.f;

	for(int i = 0; i < RAYS_PER_TEXEL; ++i)
	{
		//sample direction based on RSM texel world space
		//float3 dir = Random.SampleLevel(Point, rndUvBase + .7319542945134f * i, 1.f).xyz * 2.f - 1.f;
		float4 random = Random.SampleLevel(Point, + Seed + rndUvBase + .7319542945134f * i, 1.f);
		float3 dir = random.xyz * 2.f - 1.f;

		dir = dot(dir, normal) >= 0.f ? dir : -dir;

		float power = 1.0f / RAYS_PER_TEXEL;

		float lastIn, firstOut;
		if (rayIntersectsFrustum1(position, dir, lastIn, firstOut))
		//if (rayIntersectsLV(position, dir))
		//if(rayIntersectsFrustum(psPos.xyz, position, dir))
		{
			//no rejection, so let us emit photon
			PhotonRay pr;
			
			pr.dir = normalize(dir);

			float3 rayColor = color * power * dot(pr.dir, normal);
			pr.dir *= firstOut;

			uint encodedColor = touint(rayColor.r) | (touint(rayColor.g) << 8) | (touint(rayColor.b) << 16);
			pr.color = encodedColor;
			//pr.dir = dir;
			//Just move out the ray a bit
			pr.origin = position;// + normal * 0.f + max(0.f, lastIn) * pr.dir;
			//pr.power = color * power * dot(pr.dir, normal);
			OutRays.Append(pr);

		}
		//failed frustum check
	}
	//end of ray per texel iterator

	return 1.f.xxxx;
}
*/

float side(float3 v0, float3 v1, float3 ref, float3 p)
{
	float3 e = v1 - v0;
	float3 up = cross(e, ref - v0);
	float3 perp = cross(up, e);
	return dot(ref - v0, p - v0);
}

float3 randomInQuad(float3 v0, float3 v1, float3 v2, float3 v3, float4 random)
{
	float3 e0 = v1 - v0;
	float3 e1 = v2 - v0;
	float3 e2 = v3 - v0;
	float a0 = length(cross(e0, e1)) * 0.5f;
	float a1 = length(cross(e1, e2)) * 0.5f;

	float invAtot = 1.f / (a0 + a1);
	a0 *= invAtot;

	//Check if triangle a1 got selected
	if (random.z > a0)
	{
		v1 = v2;
		v2 = v3;
	}

	float3 p3 = v2 + v1 - v0;
	float3 x = v0 + (v1 - v0) * random.x + (v2 - v0) * random.y;
	if (side(v1, v2, v0, x) <= 0.f)
	{
		x = v0 - (x - p3);
	}
	return x;
}

#define RAYS_PER_TEXEL 1

float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	if (dot(normal, normal) < 0.5f)
	{
		discard;
	}

	float3 color = ColorSpec.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;
	float3 position = DepthToPos(depth, uv);
	float2 rndUvBase = position.xz * position.y;

	float3 lvSize = LVCellSize.xyz * LVCellSize.w;

	float sideWeights[6];

	for (int i = 1; i < 6; ++i)
	{
		uint4 sideIdx = indices[i];
		float3 v0 = corners[sideIdx.x];
		float3 v1 = corners[sideIdx.y];
		float3 v2 = corners[sideIdx.z];
		float3 v3 = corners[sideIdx.w];

		float3 sideNormal = cross(v1 - v0, v3 - v0);

		float3 tv0 = clampToHemisphere(v0 - position, normal);
		float3 tv1 = clampToHemisphere(v1 - position, normal);
		float3 tv2 = clampToHemisphere(v2 - position, normal);
		float3 tv3 = clampToHemisphere(v3 - position, normal);

		float3 p0 = tv0 + (tv1 - tv0) * .5f;
		float3 p1 = tv1 + (tv2 - tv1) * .5f;
		float3 p2 = tv2 + (tv3 - tv2) * .5f;
		float3 p3 = tv3 + (tv0 - tv3) * .5f;

		float a = acos(dot(p0, p2));
		float b = acos(dot(p1, p3));

		float solidAngle = 4.f * asin(sin(a * .5f) * sin(b * .5f));

		float power = solidAngle / (2.0f * 3.14159265358979f);

		if (power > 0.00001f)
		{
			//float4 random = Random.SampleLevel(Point, Seed + uv + i * 0.010543245653456324f, 0.f);
			float4 random = Random.SampleLevel(Point, + Seed + rndUvBase + .7319542945134f * i, 1.f);
			//Emit the photon!
			PhotonRay pr;
			
			float3 rndL0 = v0 + (v1 - v0) * random.x;
			float3 rndL1 = v2 + (v3 - v0) * random.x;

			float3 target = randomInQuad(v0, v1, v2, v3, random);
			pr.dir = normalize(target - position);
			if (dot(pr.dir, normal) > 0.f)
			{
				//Just move out the ray a bit
				pr.origin = position;// + normal * 50.f;


				float3 rayColor = color * power * dot(pr.dir, normal);
				uint encodedColor = touint(rayColor.r) | (touint(rayColor.g) << 8) | (touint(rayColor.b) << 16);
				pr.color = encodedColor;

				OutRays.Append(pr);
			}
		}
	}


	return 1.f.xxxx;
}
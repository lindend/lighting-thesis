#include "globals.incl"
#include "RayTracing/PhotonRay.incl"

AppendStructuredBuffer<PhotonRay> OutRays : register(u1);

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), LightViewProj);
	return worldPos.xyz / worldPos.w;
}

float2 toPolar(float3 v)
{
	return float2(atan(v.y / v.x), acos(v.z));
}

float3 fromPolar(float2 v)
{
	float2 scTheta, scPhi;
	sincos(v.x, scTheta.x, scTheta.y);
	sincos(v.y, scPhi.x, scPhi.y);
	return float3(scTheta.y * scPhi.x, scTheta.x * scPhi.x, scPhi.y);
}

float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 color = ColorSpec.Sample(Point, uv).xyz;
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;

	float3 position = DepthToPos(depth, uv);

	float4 random = Random.Sample(Point, uv);

	float avgPower = (color.r + color.g + color.b) * 0.333f;

	float2 polarNrm = toPolar(normal);

	if (random.z <= avgPower)
	{
		//Emit the photon!
		PhotonRay pr;
		pr.origin = position;
		float2 polarAngle = float2(acos(sqrt(random.x)), 2.f * 3.1415f * random.y);
		pr.dir = normalize(random.xyz);//normal;//fromPolar(polarNrm + polarAngle);
		pr.dir *= sign(dot(pr.dir, normal));
		//pr.dir = normal;
		pr.power = color;
		OutRays.Append(pr);
	}


	return 1.f.xxxx;
}

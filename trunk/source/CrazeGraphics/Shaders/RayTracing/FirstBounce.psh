#include "globals.incl"
#include "RayTracing/PhotonRay.incl"

AppendStructuredBuffer<PhotonRay> OutRays : register(u1);

cbuffer FrustumInfo : register(b1)
{
	float3 corners[8];
};

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), LightViewProj);
	return worldPos.xyz / worldPos.w;
}

float2 toPolar(float3 v)
{
	return float2(atan(v.y / v.x), acos(v.z));
}

float3 fromPolar(float theta, float phi)
{
	float sinTheta, cosTheta;
	float sinPhi, cosPhi;
	sincos(theta, sinTheta, cosTheta);
	sincos(phi, sinPhi, cosPhi);
	return float3(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
}
float3 fromPolar(float2 thetaPhi)
{
	return fromPolar(thetaPhi.x, thetaPhi.y);
}

float3 clampToHemisphere(float3 v, float3 n)
{
	return dot(v, n) < 0.f ? normalize(v - n * dot(n, v)) : normalize(v);
}

#define RAYS_PER_TEXEL 1

float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	if (dot(normal, normal) < 0.5f)
	{
		discard;
	}

	float3 color = ColorSpec.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;
	float3 position = DepthToPos(depth, uv);

	float3 lvSize = LVCellSize.xyz * LVCellSize.w;
	
	const uint4 indices[] = 
	{
		uint4(0, 1, 2, 3),
		uint4(5, 4, 7, 6),
		uint4(1, 0, 4, 5),
		uint4(1, 5, 2, 6),
		uint4(2, 6, 7, 3),
		uint4(3, 7, 4, 0)
	};

	float sideWeights[6];

	for (int i = 0; i < 6; ++i)
	{
		uint4 sideIdx = indices[i];
		float3 v0 = corners[sideIdx.x];
		float3 v1 = corners[sideIdx.y];
		float3 v2 = corners[sideIdx.z];
		float3 v3 = corners[sideIdx.w];

		float3 sideNormal = cross(v1 - v0, v3 - v0);

		float3 tv0 = clampToHemisphere(v0 - position, normal);
		float3 tv1 = clampToHemisphere(v1 - position, normal);
		float3 tv2 = clampToHemisphere(v2 - position, normal);
		float3 tv3 = clampToHemisphere(v3 - position, normal);

		float3 p0 = tv0 + (tv1 - tv0) * .5f;
		float3 p1 = tv1 + (tv2 - tv1) * .5f;
		float3 p2 = tv2 + (tv3 - tv2) * .5f;
		float3 p3 = tv3 + (tv0 - tv3) * .5f;

		float a = acos(dot(p0, p2));
		float b = acos(dot(p1, p3));

		float solidAngle = 4.f * asin(sin(a * .5f) * sin(b * .5f));

		float power = solidAngle / (2.0f * 3.14159265358979f);

		if (power > 0.01f)
		{
			float4 random = Random.Sample(Point, uv + i * 0.1f);
			//Emit the photon!
			PhotonRay pr;
			float3 rndL0 = v0 + (v1 - v0) * random.x;
			float3 rndL1 = v2 + (v3 - v0) * random.x;
			float3 target = rndL0 + (rndL1 - rndL0) * random.y;
			pr.dir = normalize(target - position);
			if (dot(pr.dir, normal) > 0.f)
			{
				//Just move out the ray a bit
				pr.origin = position + normal * 10.f;
				pr.power = color * power * dot(pr.dir, normal);//abs(sphereRight * discRandom.x + sphereUp * discRandom.y) * 1.f;
				OutRays.Append(pr);
			}
		}
	}


	return 1.f.xxxx;
}

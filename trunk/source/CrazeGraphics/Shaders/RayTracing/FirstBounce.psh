#include "globals.incl"
#include "RayTracing/PhotonRay.incl"

AppendStructuredBuffer<PhotonRay> OutRays : register(u1);

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), LightViewProj);
	return worldPos.xyz / worldPos.w;
}

float2 toPolar(float3 v)
{
	return float2(atan(v.y / v.x), acos(v.z));
}

float3 fromPolar(float theta, float phi)
{
	float sinTheta, cosTheta;
	float sinPhi, cosPhi;
	sincos(theta, sinTheta, cosTheta);
	sincos(phi, sinPhi, cosPhi);
	return float3(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
}

float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	if (dot(normal, normal) < 0.5f)
	{
		discard;
	}

	float3 color = ColorSpec.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;

	float3 position = DepthToPos(depth, uv);


	const float3 normals[6] =
	{
		float3(1.f,		0.f,	0.f), 
		float3(-1.f,	0.f,	0.f),
		float3(0.f,		1.f,	0.f),
		float3(0.f,		-1.f,	0.f),
		float3(0.f,		0.f,	1.f),
		float3(0.f,		0.f,	-1.f),
	};

	float3 lvSize = LVCellSize.xyz * LVCellSize.w;

	float lightVolumeSideArea[] =
	{
		lvSize.y * lvSize.z,
		lvSize.x * lvSize.z,
		lvSize.x * lvSize.y,
	};

	float3 sideCenter[] = 
	{
		//Right
		LVStart + lvSize * float3(1.f, 0.5f, 0.5f),
		//Left
		LVStart + lvSize * float3(0.f, 0.5f, 0.5f),
		//Up
		LVStart + lvSize * float3(0.5f, 1.0f, 0.5f),
		//Down
		LVStart + lvSize * float3(0.5f, 0.f, 0.5f),
		//Forward
		LVStart + lvSize * float3(0.5f, 0.5f, 1.f),
		//Backward
		LVStart + lvSize * float3(0.5f, 0.5f, 0.f),
	};
	
	float power = 0;
	for(int i = 0; i < 6; i++) //for each side of the volume
	{
		float3 texelToVolumeSide = sideCenter[i] - position;
		float distSq = dot(texelToVolumeSide, texelToVolumeSide);
		float angle = saturate(dot(normals[i], texelToVolumeSide));
		power += lightVolumeSideArea[floor(i * 0.5f)] * angle / distSq;
	}

	if(power < .0001f)
	{
		discard;
	}
	color *= power;

	int RAYS_PER_TEXEL = 5;
	for(int i = 0; i < RAYS_PER_TEXEL; i++)
	{
		float4 random = Random.Sample(Point, uv * 0.01f * i);

		//Emit the photon!
		PhotonRay pr;
		float3 target = LVStart + (LVCellSize.xyz * LVCellSize.w) * random.xyz;
		pr.dir = normalize(target - position);
		//Just move out the ray a bit
		pr.origin = position + normal * 10.f;
		pr.power = color;
		OutRays.Append(pr);
	}

	return 1.f.xxxx;





	/*
	float4 random = Random.Sample(Point, uv);

	float2 polarNrm = toPolar(normal);

	//Emit the photon!
	PhotonRay pr;
	float3 rndDir = normalize(random.xyz * 2.f - 1.f);
	pr.dir = rndDir;
	pr.dir *= sign(dot(pr.dir, normal));
	//Just move out the ray a bit
	pr.origin = position + normal * 10.f;
	pr.power = color;
	OutRays.Append(pr);

	return 1.f.xxxx;
	*/
}

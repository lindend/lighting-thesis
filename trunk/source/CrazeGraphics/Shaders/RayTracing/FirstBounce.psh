#include "globals.incl"
#include "RayTracing/PhotonRay.incl"

AppendStructuredBuffer<PhotonRay> OutRays : register(u1);

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), LightViewProj);
	return worldPos.xyz / worldPos.w;
}

float2 toPolar(float3 v)
{
	return float2(atan(v.y / v.x), acos(v.z));
}

float3 fromPolar(float theta, float phi)
{
	float sinTheta, cosTheta;
	float sinPhi, cosPhi;
	sincos(theta, sinTheta, cosTheta);
	sincos(phi, sinPhi, cosPhi);
	return float3(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
}

float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	if (dot(normal, normal) < 0.5f)
	{
		discard;
	}

	float3 color = ColorSpec.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;

	float3 position = DepthToPos(depth, uv);

	float4 random = Random.Sample(Point, uv);

	float avgPower = (color.r + color.g + color.b) * 0.333f;

	float2 polarNrm = toPolar(normal);

	if (random.w <= avgPower)
	{
		//Emit the photon!
		PhotonRay pr;
		float3 rndDir = normalize(random.xyz * 2.f - 1.f);
		//pr.dir = fromPolar(2.f * 3.1415f * random.x, acos(2.f * random.y - 1.f));
		//pr.dir = normalize(random.xyz * 2.f - 1.f);//normal;//fromPolar(polarNrm + polarAngle);
		pr.dir = rndDir;
		pr.dir *= sign(dot(pr.dir, normal));
		//Just move out the ray a bit
		pr.origin = position + normal * 10.f;
		//pr.dir = normal;
		pr.power = color;
		OutRays.Append(pr);
	}


	return 1.f.xxxx;
}

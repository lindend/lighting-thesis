#include "globals.incl"
#include "RayTracing/PhotonRay.incl"

AppendStructuredBuffer<PhotonRay> OutRays : register(u1);

cbuffer FrustumInfo : register(b1)
{
	float3 corners[8];
};

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), LightViewProj);
	return worldPos.xyz / worldPos.w;
}

float2 toPolar(float3 v)
{
	return float2(atan(v.y / v.x), acos(v.z));
}

float3 fromPolar(float theta, float phi)
{
	float sinTheta, cosTheta;
	float sinPhi, cosPhi;
	sincos(theta, sinTheta, cosTheta);
	sincos(phi, sinPhi, cosPhi);
	return float3(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
}
float3 fromPolar(float2 thetaPhi)
{
	return fromPolar(thetaPhi.x, thetaPhi.y);
}

float3 clampToHemisphere(float3 v, float3 n)
{
	return dot(v, n) < 0.f ? normalize(v - n * dot(n, v)) : normalize(v);
}

static const uint4 indices[] = 
{
	uint4(0, 1, 2, 3), //back
	uint4(5, 4, 7, 6), //forward
	uint4(1, 0, 4, 5), //top
	uint4(1, 5, 6, 2), //right
	uint4(2, 6, 7, 3), //bottom
	uint4(3, 7, 4, 0) //left
};

float3 calcFrustumNormal(int frustumIndex)
{
	//(V2 - V1) x (V3 - V1)
	uint4 side = indices[frustumIndex];
	float3 v0 = corners[side.x];
	float3 v1 = corners[side.y];
	float3 v2 = corners[side.w];
	return normalize(cross(v1 - v0, v2 - v0));
}

bool rayIntersectsFrustum1(float3 rayOrigin, float3 rayDir)
{
	float maxEnter = -213321456621321122131.0f;
	float minExit = 1315677621313213321.0f;
	//bool inside[6];
	bool inside = true;
	for(int i = 0; i < 6; ++i)
	{
		float3 frustumN = calcFrustumNormal(i);
		float frustDotDir = dot(frustumN, rayDir);
		float signDist = dot(frustumN , corners[indices[i].x] - rayOrigin);
		inside = inside && (signDist < 0.f || frustDotDir > 0.f);
		
		if(abs(frustDotDir) > 0.00001f) //if == 0, ray is parallel to plane so they either always intersect or never does
		{
			float intersection = signDist / frustDotDir;
			
			if(frustDotDir > 0.f)
			{
				maxEnter = max(intersection, maxEnter);
			}
			else
			{
				minExit = min(intersection, minExit);
			}
		}
	}
	//return inside;

	return maxEnter < minExit;
}

bool rayIntersectsLV(float3 o, float3 d)
{
	float3 invDir = rcp(d);
	float3 tBegin = (LVStart - o) * invDir;
	float3 tEnd = (LVEnd - o) * invDir;
	 
	float3 tEnter = min(tBegin, tEnd);
	float3 tExit = max(tBegin, tEnd);
	float tMaxEnter = max(tEnter.x, max(tEnter.y, tEnter.z));
	float tMinExit = min(tExit.x, min(tExit.y, tExit.z));
	return tMaxEnter < tMinExit;
}

float3 toPSpace(float3 v, float w = 1.f)
{
	float4 ps = mul(float4(v, w), ViewProj);
	ps.xyz /= ps.w;
	return ps.xyz;
}
bool rayIntersectsFrustum(float3 psOrigin, float3 o, float3 d)
{
	float3 dir = toPSpace(d, 0.f);
	float3 toMin = float3(-1.f, -1.f, 0.f) - psOrigin;
	float3 toMax = float3(1.f, 1.f, 1.f) - psOrigin;
	float3 tMins = toMin / dir;
	float3 tMaxs = toMax / dir;

	float3 dirSign = sign(dir);
	float3 posDirMask = max(0.f, dirSign);
	float3 negDirMask = max(0.f, -dirSign);
	float3 enters = posDirMask * tMins + negDirMask * tMaxs;
	float3 exits = negDirMask * tMins + posDirMask * tMaxs;

	return max(enters.x, max(enters.y, enters.z)) <= min(exits.x, min(exits.y, exits.z));
}

#define RAYS_PER_TEXEL 4

float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	if (dot(normal, normal) < 0.5f)
	{
		discard;
	}

	float3 color = ColorSpec.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;
	float3 position = DepthToPos(depth, uv);
	position = floor(position / 2.f) * 2.f;
	float3 psPos = toPSpace(position);

	float2 rndUvBase = position.xz / 10.f;//floor(frac(position.xz * 0.001f) * 128.f) / 128.f;

	for(int i = 0; i < RAYS_PER_TEXEL; ++i)
	{
		//sample direction based on RSM texel world space
		float3 dir = Random.SampleLevel(Point, rndUvBase + .7319542945134f * i, 1.f).xyz * 2.f - 1.f; //TODO
		dir = dot(dir, normal) > 0 ? dir : -dir;

		float power = 7.0f / RAYS_PER_TEXEL;

		if (rayIntersectsFrustum1(position, dir))
		//if (rayIntersectsLV(position, dir))
		//if(rayIntersectsFrustum(psPos.xyz, position, dir))
		{
			//no rejection, so let us emit photon
			PhotonRay pr;
			
			pr.dir = normalize(dir);
			//pr.dir = dir;
			//Just move out the ray a bit
			pr.origin = position + normal * 0.f;
			pr.power = color * power * dot(pr.dir, normal);
			OutRays.Append(pr);

		}
		//failed frustum check
	}
	//end of ray per texel iterator

	return 1.f.xxxx;
}

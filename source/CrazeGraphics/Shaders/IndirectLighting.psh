#include "globals.incl"
#include "SHMath.incl"
#include "RayTracing/CMSides.incl"

//#define CRAZE_USE_SH_LV


static const SamplerState LVSampler = Point;

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), InvViewProj);
	return worldPos.xyz / worldPos.w;
} 

float3 cellFromPos(float3 worldPos)
{
	float3 localPos = (worldPos - LVStart) / ((LVCellSize.w) * LVCellSize.xyz);
	localPos.y = 1.f - localPos.y;
	return localPos;
}

#ifdef CRAZE_USE_SH_LV
float3 evalIndirectLightAt(float3 cell, float3 normal)
{
	float4 redSH = LightVolumeR.Sample(LVSampler, cell);
	float4 greenSH = LightVolumeG.Sample(LVSampler, cell);
	float4 blueSH = LightVolumeB.Sample(LVSampler, cell);

	float4 sh = EvalSH(-normal);

	return max(0.f, float3(dot(redSH, sh), dot(greenSH, sh), dot(blueSH, sh)) * 0.3f);

}
#else
float3 interpolateGamma(float3 s0, float3 s1, float p)
{
	//In order to have a smooth curve, we need to know which is the darkest
	if (dot(s0, s0) > dot(s1, s1))
	{
		float3 tmp = s0;
		s0 = s1;
		s1 = tmp;
		p = 1.f - p;
	}
	float3 delta = s1 - s0;

	return s0 + delta * pow(p, 2.2f);
}

float3 gammaTrilinearSample(Texture3D tex, float3 cell)
{
	cell += 0.5f / LVCellSize.w;
	float3 texCoords = cell * LVCellSize.w;
	int4 baseUv = int4(texCoords, 0);
	float3 samples[8];
	float3 p = 1.f - frac(texCoords);
	samples[0] = tex.Load(baseUv, -int3(0, 0, 0)).xyz;
	samples[1] = tex.Load(baseUv, -int3(1, 0, 0)).xyz;
	samples[2] = tex.Load(baseUv, -int3(0, 1, 0)).xyz;
	samples[3] = tex.Load(baseUv, -int3(1, 1, 0)).xyz;
	samples[4] = tex.Load(baseUv, -int3(0, 0, 1)).xyz;
	samples[5] = tex.Load(baseUv, -int3(1, 0, 1)).xyz;
	samples[6] = tex.Load(baseUv, -int3(0, 1, 1)).xyz;
	samples[7] = tex.Load(baseUv, -int3(1, 1, 1)).xyz;

	float3 x0z0 = interpolateGamma(samples[0], samples[1], p.x);
	float3 x1z0 = interpolateGamma(samples[2], samples[3], p.x);
	float3 yz0 = interpolateGamma(x0z0, x1z0, p.y);
	float3 x0z1 = interpolateGamma(samples[4], samples[5], p.x);
	float3 x1z1 = interpolateGamma(samples[6], samples[7], p.x);
	float3 yz1 = interpolateGamma(x0z1, x1z1, p.y);
	return interpolateGamma(yz0, yz1, p.z);
}

float3 sampleSide(Texture3D side, float3 cell, float3 normal)
{
	const float normalOffsetDist = 40.f;
	const float gridOffsetFactor = 1.f / (LVCellSize.x * LVCellSize.w);
	//float3 color = gammaTrilinearSample(side, cell);
	float3 color = side.SampleLevel(LVSampler, cell, 0.f);
	normal.y = -normal.y;
	const float outwardColor = length(side.SampleLevel(LVSampler, cell + normal * normalOffsetDist * gridOffsetFactor, 0.f).xyz);
	
	float delta = max(0.f, length(color) - outwardColor);
	//color *= pow(1.f - smoothstep(0.f, 0.02f, delta), 2.f);
	return saturate(color);
}

float3 evalIndirectLightAt(float3 cell, float3 normal)
{ 
	float p = 1.f;
	float sideWeights[6];
	for (int i = 0; i < 6; ++i)
	{
		sideWeights[i] = pow(saturate(dot(CMSides[i], -normal)), 2.2f);
	}

	float3 color = 0.f;

	if (sideWeights[0] > 0.f)
	{
		color += sideWeights[0] * sampleSide(LightVolumeRight, cell, normal);
	} else if (sideWeights[1] > 0.f)
	{
		color += sideWeights[1] * sampleSide(LightVolumeLeft, cell, normal);
	}

	if (sideWeights[2] > 0.f)
	{
		color += sideWeights[2] * sampleSide(LightVolumeTop, cell, normal);
	} else if(sideWeights[3] > 0.f)
	{
		color += sideWeights[3] * sampleSide(LightVolumeBot, cell, normal);
	}

	if (sideWeights[4] > 0.f)
	{
		color += sideWeights[4] * sampleSide(LightVolumeFront, cell, normal);
	} else if(sideWeights[5] > 0.f)
	{
		color += sideWeights[5] * sampleSide(LightVolumeBack, cell, normal);
	}

	return color;
}
#endif
float4 main(float2 uv : TEXCOORD0) : SV_Target0
{
	float3 color = ColorSpec.Sample(Point, uv).xyz;

	float3 normal = NormalRough.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;
	float3 pos = DepthToPos(depth, uv);

	if (dot(normal, normal) < 0.5f)
	{
		//return float4(pow(color, 2.2f), 1.f);
	}

	float3 cell = cellFromPos(pos);

	if (max(cell.x, cell.y) > 1.f || min(cell.x, cell.y) < 0.f || cell.z < 0.f || cell.z > 1.f)
	{
		discard;
	}
	float lightScale = 0.8f * pow(LVCellSize.w / 16.f, 3);
	float3 light = evalIndirectLightAt(cell, normal) * lightScale;

	#ifdef CRAZE_INTERPOLATION_GAMMA_CHEAT
	light = pow(light, 2.2f) * 4.f;
	#endif
	float3 ambient = float3(0.018f, 0.018f, 0.021f);
	ambient = 0.01f;
	return float4(max(light, ambient) * color, 1.0f);
}
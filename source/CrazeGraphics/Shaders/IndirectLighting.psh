#include "globals.incl"
#include "SHMath.incl"
#include "RayTracing/CMSides.incl"

//#define CRAZE_USE_SH_LV

static const SamplerState LVSampler = BilinearBorder;

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), InvViewProj);
	return worldPos.xyz / worldPos.w;
}

float3 cellFromPos(float3 worldPos)
{
	float3 localPos = (worldPos - LVStart) / (LVCellSize.w * LVCellSize.xyz);
	//localPos.z *= LVCellSize.w;
	localPos.y = 1.f - localPos.y;
	return localPos;
}
#ifdef CRAZE_USE_SH_LV
float3 evalIndirectLightAt(float3 cell, float3 normal)
{
	float4 redSH = LightVolumeR.Sample(LVSampler, cell);
	float4 greenSH = LightVolumeG.Sample(LVSampler, cell);
	float4 blueSH = LightVolumeB.Sample(LVSampler, cell);

	float4 sh = EvalSH(-normal);

	return max(0.f, float3(dot(redSH, sh), dot(greenSH, sh), dot(blueSH, sh)) * 0.3f);

}
#else
float3 evalIndirectLightAt(float3 cell, float3 normal)
{ 
	float p = 1.f;
	float sideWeights[6];
	for (int i = 0; i < 6; ++i)
	{
		sideWeights[i] = saturate(dot(CMSides[i], -normal));
	}
	
	float3 color = 0.f;
	if (sideWeights[0] > 0.f)
	{
		color += sideWeights[0] * LightVolumeRight.SampleLevel(LVSampler, cell, 0.f).xyz;
	} else if (sideWeights[1] > 0.f)
	{
		color += sideWeights[1] * LightVolumeLeft.SampleLevel(LVSampler, cell, 0.f).xyz;
	}

	if (sideWeights[2] > 0.f)
	{
		color += sideWeights[2] * LightVolumeTop.SampleLevel(LVSampler, cell, 0.f).xyz;
	} else if(sideWeights[3] > 0.f)
	{
		color += sideWeights[3] * LightVolumeBot.SampleLevel(LVSampler, cell, 0.f).xyz;
	}

	if (sideWeights[4] > 0.f)
	{
		color += sideWeights[4] * LightVolumeFront.SampleLevel(LVSampler, cell, 0.f).xyz;
	} else if(sideWeights[5] > 0.f)
	{
		color += sideWeights[5] * LightVolumeBack.SampleLevel(LVSampler, cell, 0.f).xyz;
	}

	return color * 3.74f;
}
#endif
float4 main(float2 uv : TEXCOORD0) : SV_Target0
{
	float3 color = ColorSpec.Sample(Point, uv).xyz;

	float3 normal = NormalRough.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;
	float3 pos = DepthToPos(depth, uv);

	float3 cell = cellFromPos(pos);

	if (max(cell.x, cell.y) > 1.f || min(cell.x, cell.y) < 0.f || cell.z < 0.f || cell.z > 1.f)
	{
		discard;
	}

	//return cell.xyzx;

	float lightScale = 0.3f;
	float3 light = evalIndirectLightAt(cell, normal) * lightScale;
	float3 lightAtNormal = evalIndirectLightAt(cellFromPos(pos + normal * 150.f), normal) * lightScale;
	if (uv.x > 0.f)
	{
		float fr = length(lightAtNormal) / length(light);
		fr = fr < 1.f ? fr : 1.f / fr;
		if (!isnan(fr))
		{
			//light *= fr;
		}
	}

	float3 eLight = 0.f;
	/*float3 toCam = normalize(CameraPos.xyz - pos);
	float ptDist = distance(pos, CameraPos.xyz);
	float splits = min(10.f, ptDist / 200.f);
	[unroll(10)]
	for (int i = 0; i < splits - 1; ++i)
	{
		eLight += 0.01f * evalIndirectLightAt(cellFromPos(lerp(pos, CameraPos.xyz, i / splits)), -1.f);
	}
	eLight += 0.01f * evalIndirectLightAt(cellFromPos(CameraPos.xyz), -1.f) * (splits / floor(splits));
	//if (uv.x > 0.5f)
	{
		
		eLight *= 1.f / (floor(splits) / splits);
	}*/

	return float4(light * color + eLight * 0.1f, 1.0f);
}
#include "globals.incl"
#include "RayTracing/PhotonRay.incl"

AppendStructuredBuffer<PhotonRay> OutRays : register(u1);

cbuffer FrustumInfo : register(b1)
{
	float3 corners[8];
};

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), LightViewProj);
	return worldPos.xyz / worldPos.w;
}

float2 toPolar(float3 v)
{
	return float2(atan(v.y / v.x), acos(v.z));
}

float3 fromPolar(float theta, float phi)
{
	float sinTheta, cosTheta;
	float sinPhi, cosPhi;
	sincos(theta, sinTheta, cosTheta);
	sincos(phi, sinPhi, cosPhi);
	return float3(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
}
float3 fromPolar(float2 thetaPhi)
{
	return fromPolar(thetaPhi.x, thetaPhi.y);
}

float3 clampToHemisphere(float3 v, float3 n)
{
	return dot(v, n) < 0.f ? normalize(v - n * dot(n, v)) : normalize(v);
}

float3 randomInQuad(float3 v0, float3 v1, float3 v2, float3 v3, float4 random)
{
	float3 e0 = v1 - v0;
	float3 e1 = v2 - v0;
	float3 e2 = v3 - v0;
	float a0 = length(cross(e0, e1)) * 0.5f;
	float a1 = length(cross(e1, e2)) * 0.5f;

	float invAtot = 1.f / (a0 + a1);
	a0 *= invAtot;

	//Check if triangle a1 got selected
	if (random.z < a0)
	{
		v1 = v2;
		v2 = v3;
	}

	float3 p3 = v2 + v1 - v0;
	float3 x = v0 + (v1 - v0) * random.x + (v2 - v0) * random.y;
	//if (dot(normalize(x - v1), normalize(v2 - v1)) <= dot(normalize(v2 - v1), normalize(v0 - v1)))

	if (distance(x, v0) < distance(x, v3))
	{
		x = v0 - (x - p3);
	}
	return x;
}

#define RAYS_PER_TEXEL 1

float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	if (dot(normal, normal) < 0.5f)
	{
		discard;
	}

	float3 color = ColorSpec.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;
	float3 position = DepthToPos(depth, uv);

	float3 lvSize = LVCellSize.xyz * LVCellSize.w;
	
	const uint4 indices[] = 
	{
		uint4(0, 1, 2, 3),
		uint4(5, 4, 7, 6),
		uint4(1, 0, 4, 5),
		uint4(1, 5, 2, 6),
		uint4(2, 6, 7, 3),
		uint4(3, 7, 4, 0)
	};

	float sideWeights[6];

	for (int i = 0; i < 6; ++i)
	{
		uint4 sideIdx = indices[i];
		float3 v0 = corners[sideIdx.x];
		float3 v1 = corners[sideIdx.y];
		float3 v2 = corners[sideIdx.z];
		float3 v3 = corners[sideIdx.w];

		float3 sideNormal = cross(v1 - v0, v3 - v0);

		float3 tv0 = clampToHemisphere(v0 - position, normal);
		float3 tv1 = clampToHemisphere(v1 - position, normal);
		float3 tv2 = clampToHemisphere(v2 - position, normal);
		float3 tv3 = clampToHemisphere(v3 - position, normal);

		float3 p0 = tv0 + (tv1 - tv0) * .5f;
		float3 p1 = tv1 + (tv2 - tv1) * .5f;
		float3 p2 = tv2 + (tv3 - tv2) * .5f;
		float3 p3 = tv3 + (tv0 - tv3) * .5f;

		float a = acos(dot(p0, p2));
		float b = acos(dot(p1, p3));

		float solidAngle = 4.f * asin(sin(a * .5f) * sin(b * .5f));

		float power = solidAngle / (2.0f * 3.14159265358979f);

		if (power > 0.00001f)
		{
			float4 random = Random.Sample(Point, uv + i * 0.1f);
			//Emit the photon!
			PhotonRay pr;
			
			float3 rndL0 = v0 + (v1 - v0) * random.x;
			float3 rndL1 = v2 + (v3 - v0) * random.x;
			//float3 target = rndL0 + (rndL1 - rndL0) * random.y;
			float3 target = randomInQuad(v0, v1, v2, v3, random);
			pr.dir = normalize(target - position);
			if (dot(pr.dir, normal) > 0.f)
			{
				//Just move out the ray a bit
				pr.origin = position + normal * 50.f;
				pr.power = color * power * dot(pr.dir, normal);//abs(sphereRight * discRandom.x + sphereUp * discRandom.y) * 1.f;
				OutRays.Append(pr);
			}
		}
	}


	return 1.f.xxxx;
}

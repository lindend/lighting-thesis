#include "globals.incl"
#include "RayTracing/PhotonRay.incl"

AppendStructuredBuffer<PhotonRay> OutRays : register(u1);

cbuffer FrustumInfo : register(b1)
{
	float3 corners[8];
};

float3 DepthToPos(float depth, float2 uv)
{
	float4 worldPos = mul(float4(float2(uv.x, 1.f - uv.y) * 2.f - 1.f, depth, 1.0f), LightViewProj);
	return worldPos.xyz / worldPos.w;
}

float2 toPolar(float3 v)
{
	return float2(atan(v.y / v.x), acos(v.z));
}

float3 fromPolar(float theta, float phi)
{
	float sinTheta, cosTheta;
	float sinPhi, cosPhi;
	sincos(theta, sinTheta, cosTheta);
	sincos(phi, sinPhi, cosPhi);
	return float3(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
}
float3 fromPolar(float2 thetaPhi)
{
	return fromPolar(thetaPhi.x, thetaPhi.y);
}

float3 clampToHemisphere(float3 v, float3 n)
{
	return dot(v, n) < 0.f ? normalize(v - n * dot(n, v)) : normalize(v);
}

static const uint4 indices[] = 
{
	uint4(0, 1, 2, 3), //back
	uint4(5, 4, 7, 6), //forward
	uint4(1, 0, 4, 5), //top
	uint4(1, 5, 2, 6), //right
	uint4(2, 6, 7, 3), //bottom
	uint4(3, 7, 4, 0) //left
};

float3 calcFrustumNormal(int frustumIndex)
{
	//(V2 - V1) x (V3 - V1)
	uint4 side = indices[frustumIndex];
	float3 v0 = corners[side.x];
	float3 v1 = corners[side.y];
	float3 v2 = corners[side.w];
	return cross(v1 - v0, v2 - v0);
	return cross(corners[indices[frustumIndex].y] - corners[indices[frustumIndex].x] , corners[indices[frustumIndex].w] - corners[indices[frustumIndex].x]);
}

bool rayIntersectsFrustum(float3 rayOrigin, float3 rayDir)
{
	float maxEnter = -21332121321122131.0f;
	float minExit = 13121313213321.0f;

	for(int i = 0; i < 6; i++)
	{
		//-n dot w / n dot u
		//w = P0 - V0
		//u = P1 - P0

		if(dot(calcFrustumNormal(i), rayDir) != 0.f) //if == 0, ray is parallel to plane so they either always intersect or never does
		{
			float3 frustumN = calcFrustumNormal(i);
			float intersection = dot(-frustumN , rayOrigin - corners[indices[i].x]) / dot(frustumN , rayDir);

			if(dot(frustumN, rayDir) > 0)
			{
				maxEnter = max(intersection, maxEnter);
			}
			else
			{
				minExit = min(intersection, minExit);
			}
		}
	}

	return maxEnter < minExit;
}

#define RAYS_PER_TEXEL 5

float4 main(float2 uv : TEXCOORD0, float4 pos : SV_Position) : SV_Target0
{
	float3 normal = NormalRough.Sample(Point, uv).xyz;
	if (dot(normal, normal) < 0.5f)
	{
		discard;
	}

	float3 color = ColorSpec.Sample(Point, uv).xyz;
	float depth = Depth.Sample(Point, uv).x;
	float3 position = DepthToPos(depth, uv);

	for(int i = 0; i < RAYS_PER_TEXEL; ++i)
	{
		//sample direction based on RSM texel world space
		float3 dir = Random.SampleLevel(Point, (uv) + .019542945134f * i, 0.f).xyz * 2.f - 1.f; //TODO
		dir = dot(dir, normal) > 0 ? dir : -dir;

		float power = 7.0f / RAYS_PER_TEXEL;

		if(rayIntersectsFrustum(position, dir))
		{
			//no rejection, so let us emit photon
			PhotonRay pr;
			
			pr.dir = dir;

			//Just move out the ray a bit
			pr.origin = position + normal * 0.f;
			pr.power = color * power * dot(pr.dir, normal);
			OutRays.Append(pr);

		}
		//failed frustum check
	}
	//end of ray per texel iterator

	return 1.f.xxxx;
}
